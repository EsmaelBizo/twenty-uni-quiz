[
  {
    "title": "بعد تنفيذ خطوة Partitioning في خوارزمية QuickSort، أي مما يلي يكون مضمونًا؟",
    "answer_1": "المصفوفة أصبحت مرتبة بالكامل",
    "answer_2": "العناصر قُسمت إلى مجموعتين بالنسبة للمحور",
    "answer_3": "تم اختيار أصغر عنصر كمحور",
    "answer_4": "لم يعد هناك حاجة لاستدعاء تراجعي",
    "correct_ans": "العناصر قُسمت إلى مجموعتين بالنسبة للمحور"
  },
  {
    "title": "أي مما يلي لا يمكن أن يكون نتيجة مباشرة لعملية Partitioning واحدة؟",
    "answer_1": "وجود عناصر أصغر من المحور في جهة واحدة",
    "answer_2": "وجود عناصر أكبر من المحور في الجهة المقابلة",
    "answer_3": "ترتيب كامل لجميع عناصر المصفوفة",
    "answer_4": "تحديد نقطة فصل بين قسمين",
    "correct_ans": "ترتيب كامل لجميع عناصر المصفوفة"
  },
  {
    "title": "لماذا تُطبّق QuickSort تراجعيًا على الأقسام الناتجة بعد Partitioning؟",
    "answer_1": "لأن العناصر أصبحت عشوائية",
    "answer_2": "لأن كل قسم يمثل مشكلة أصغر من نفس النوع",
    "answer_3": "لأن المحور قد يتغير",
    "answer_4": "لأن المصفوفة لم تعد صالحة",
    "correct_ans": "لأن كل قسم يمثل مشكلة أصغر من نفس النوع"
  },
  {
    "title": "أي حالة تجعل جزءًا من المصفوفة لا يحتاج إلى معالجة إضافية في QuickSort؟",
    "answer_1": "عندما يحتوي على عنصر واحد أو يكون فارغًا",
    "answer_2": "عندما يحتوي على عناصر متساوية",
    "answer_3": "عندما يكون المحور في الوسط",
    "answer_4": "بعد أول Partitioning",
    "correct_ans": "عندما يحتوي على عنصر واحد أو يكون فارغًا"
  },
  {
    "title": "في حال تم اختيار محور غير مناسب بشكل متكرر، ما الأثر المتوقع على تنفيذ QuickSort؟",
    "answer_1": "توقف الخوارزمية",
    "answer_2": "زيادة عدد خطوات التقسيم والاستدعاء",
    "answer_3": "الحصول على ترتيب خاطئ",
    "answer_4": "عدم تنفيذ Partitioning",
    "correct_ans": "زيادة عدد خطوات التقسيم والاستدعاء"
  },
  {
    "title": "متى نعتبر أن QuickSort أنهى ترتيب المصفوفة بالكامل؟",
    "answer_1": "بعد تنفيذ أول Partitioning",
    "answer_2": "بعد ترتيب جميع الأقسام الناتجة",
    "answer_3": "عند اختيار محور مناسب",
    "answer_4": "عند تساوي جميع العناصر",
    "correct_ans": "بعد ترتيب جميع الأقسام الناتجة"
  },
  {
    "title": "ما الهدف الأساسي من خوارزمية QuickSort؟",
    "answer_1": "تقليل عدد العناصر",
    "answer_2": "ترتيب العناصر باستخدام التقسيم والاستدعاء التراجعي",
    "answer_3": "البحث عن عنصر محدد",
    "answer_4": "دمج مصفوفتين",
    "correct_ans": "ترتيب العناصر باستخدام التقسيم والاستدعاء التراجعي"
  },
  {
    "title": "ما النتيجة المباشرة لعملية Partitioning في QuickSort؟",
    "answer_1": "ترتيب كامل للمصفوفة",
    "answer_2": "تقسيم العناصر إلى قسمين بالنسبة لمحور",
    "answer_3": "اختيار أصغر عنصر",
    "answer_4": "إلغاء الاستدعاء التراجعي",
    "correct_ans": "تقسيم العناصر إلى قسمين بالنسبة لمحور"
  },
  {
    "title": "أي عبارة تصف حالة العناصر بعد تنفيذ Partitioning مباشرة؟",
    "answer_1": "العناصر مرتبة بالكامل",
    "answer_2": "كل العناصر الأصغر من المحور في جهة واحدة",
    "answer_3": "العناصر موزعة عشوائيًا",
    "answer_4": "العناصر الأكبر في اليسار دائمًا",
    "correct_ans": "كل العناصر الأصغر من المحور في جهة واحدة"
  },
  {
    "title": "لماذا يتم تطبيق QuickSort بشكل تراجعي على الأقسام الناتجة؟",
    "answer_1": "لأن المصفوفة أصبحت أصغر",
    "answer_2": "لترتيب كل قسم بشكل مستقل",
    "answer_3": "لإعادة اختيار محور جديد",
    "answer_4": "لمنع التكرار",
    "correct_ans": "لترتيب كل قسم بشكل مستقل"
  },
  {
    "title": "أي حالة تجعل QuickSort يتوقف عن الاستدعاء التراجعي؟",
    "answer_1": "عند تساوي جميع العناصر",
    "answer_2": "عندما يصبح القسم بطول صفر أو واحد",
    "answer_3": "عند اختيار محور جيد",
    "answer_4": "بعد أول تقسيم",
    "correct_ans": "عندما يصبح القسم بطول صفر أو واحد"
  },
  {
    "title": "لماذا يُعتبر QuickSort خوارزمية Divide and Conquer؟",
    "answer_1": "لأنه يستخدم مصفوفة إضافية",
    "answer_2": "لأنه يقسم المشكلة إلى مشاكل أصغر ثم يحلها",
    "answer_3": "لأنه يعمل بدون recursion",
    "answer_4": "لأنه يعتمد على الدمج",
    "correct_ans": "لأنه يقسم المشكلة إلى مشاكل أصغر ثم يحلها"
  },
  {
    "title": "أي ميزة لـ QuickSort تميزها عن MergeSort؟",
    "answer_1": "لا يستخدم recursion",
    "answer_2": "لا يحتاج خطوة دمج",
    "answer_3": "أبطأ دائمًا",
    "answer_4": "يستخدم ذاكرة إضافية",
    "correct_ans": "لا يحتاج خطوة دمج"
  },
  {
    "title": "متى نعتبر أن QuickSort أنهى عمله على المصفوفة بالكامل؟",
    "answer_1": "بعد أول Partitioning",
    "answer_2": "عند ترتيب جميع الأقسام الناتجة",
    "answer_3": "عند اختيار المحور",
    "answer_4": "عند عدم وجود عناصر متساوية",
    "correct_ans": "عند ترتيب جميع الأقسام الناتجة"
  },
  {
    "title": "ما الهدف الأساسي من خوارزمية QuickSort؟",
    "answer_1": "تقليل عدد العناصر",
    "answer_2": "ترتيب العناصر باستخدام التقسيم والاستدعاء التراجعي",
    "answer_3": "البحث عن عنصر محدد",
    "answer_4": "دمج مصفوفتين",
    "correct_ans": "ترتيب العناصر باستخدام التقسيم والاستدعاء التراجعي"
  },
  {
    "title": "ما النتيجة المباشرة لعملية Partitioning في QuickSort؟",
    "answer_1": "ترتيب كامل للمصفوفة",
    "answer_2": "تقسيم العناصر إلى قسمين بالنسبة لمحور",
    "answer_3": "اختيار أصغر عنصر",
    "answer_4": "إلغاء الاستدعاء التراجعي",
    "correct_ans": "تقسيم العناصر إلى قسمين بالنسبة لمحور"
  },
  {
    "title": "أي عبارة تصف حالة العناصر بعد تنفيذ Partitioning مباشرة؟",
    "answer_1": "العناصر مرتبة بالكامل",
    "answer_2": "كل العناصر الأصغر من المحور في جهة واحدة",
    "answer_3": "العناصر موزعة عشوائيًا",
    "answer_4": "العناصر الأكبر في اليسار دائمًا",
    "correct_ans": "كل العناصر الأصغر من المحور في جهة واحدة"
  },
  {
    "title": "لماذا يتم تطبيق QuickSort بشكل تراجعي على الأقسام الناتجة؟",
    "answer_1": "لأن المصفوفة أصبحت أصغر",
    "answer_2": "لترتيب كل قسم بشكل مستقل",
    "answer_3": "لإعادة اختيار محور جديد",
    "answer_4": "لمنع التكرار",
    "correct_ans": "لترتيب كل قسم بشكل مستقل"
  },
  {
    "title": "أي حالة تجعل QuickSort يتوقف عن الاستدعاء التراجعي؟",
    "answer_1": "عند تساوي جميع العناصر",
    "answer_2": "عندما يصبح القسم بطول صفر أو واحد",
    "answer_3": "عند اختيار محور جيد",
    "answer_4": "بعد أول تقسيم",
    "correct_ans": "عندما يصبح القسم بطول صفر أو واحد"
  },
  {
    "title": "متى نعتبر أن QuickSort أنهى عمله على المصفوفة بالكامل؟",
    "answer_1": "بعد أول Partitioning",
    "answer_2": "عند ترتيب جميع الأقسام الناتجة",
    "answer_3": "عند اختيار المحور",
    "answer_4": "عند عدم وجود عناصر متساوية",
    "correct_ans": "عند ترتيب جميع الأقسام الناتجة"
  },
  {
    "title": "ما الهدف من استخدام مؤشرين يتحركان من جهتين متعاكستين في خوارزمية QuickSort؟",
    "answer_1": "لتقليل عدد العناصر",
    "answer_2": "لتقسيم العناصر بالنسبة للمحور",
    "answer_3": "لتسريع الاستدعاء التراجعي",
    "answer_4": "لتفادي استخدام recursion",
    "correct_ans": "لتقسيم العناصر بالنسبة للمحور"
  },
  {
    "title": "أثناء تنفيذ QuickSort، متى يتم تبديل عنصرين داخل المصفوفة؟",
    "answer_1": "عندما يكون العنصران متجاورين",
    "answer_2": "عندما يكون أحدهما في الجهة الخاطئة بالنسبة للمحور",
    "answer_3": "بعد كل مقارنة",
    "answer_4": "فقط في نهاية الخوارزمية",
    "correct_ans": "عندما يكون أحدهما في الجهة الخاطئة بالنسبة للمحور"
  },
  {
    "title": "ما النتيجة المباشرة لعملية Partitioning في QuickSort؟",
    "answer_1": "ترتيب كامل للمصفوفة",
    "answer_2": "تقسيم المصفوفة إلى قسمين حول محور",
    "answer_3": "اختيار أصغر عنصر",
    "answer_4": "إلغاء الحاجة للاستدعاء التراجعي",
    "correct_ans": "تقسيم المصفوفة إلى قسمين حول محور"
  },
  {
    "title": "لماذا لا نعيد معالجة عنصر المحور بعد تنفيذ Partitioning؟",
    "answer_1": "لأنه حُذف من المصفوفة",
    "answer_2": "لأنه أصبح في موقعه الصحيح",
    "answer_3": "لأنه أكبر عنصر",
    "answer_4": "لأنه لا يؤثر على النتيجة",
    "correct_ans": "لأنه أصبح في موقعه الصحيح"
  },
  {
    "title": "ما الخطأ المنطقي إذا استمر الاستدعاء التراجعي بدون شروط إيقاف صحيحة في QuickSort؟",
    "answer_1": "ترتيب غير صحيح",
    "answer_2": "حلقة لا نهائية أو استدعاءات زائدة",
    "answer_3": "تجاهل بعض العناصر",
    "answer_4": "زيادة الذاكرة فقط",
    "correct_ans": "حلقة لا نهائية أو استدعاءات زائدة"
  },
  {
    "title": "في Binary Search Tree، عند إدخال قيمة أصغر من قيمة العقدة الحالية، إلى أي فرع ننتقل؟",
    "answer_1": "الفرع الأيمن",
    "answer_2": "الفرع الأيسر",
    "answer_3": "الجذر مباشرة",
    "answer_4": "نتوقف عن الإدخال",
    "correct_ans": "الفرع الأيسر"
  },
  {
    "title": "في عملية البحث عن قيمة داخل BST باستخدام حلقة while، متى تتوقف الحلقة؟",
    "answer_1": "عند الوصول إلى عقدة ورقية فقط",
    "answer_2": "عند العثور على القيمة أو الوصول إلى NULL",
    "answer_3": "عند مقارنة أول عقدة فقط",
    "answer_4": "عند الانتقال إلى الفرع الأيمن",
    "correct_ans": "عند العثور على القيمة أو الوصول إلى NULL"
  },
  {
    "title": "ما نتيجة تنفيذ العبور من نوع Inorder على Binary Search Tree؟",
    "answer_1": "عناصر مرتبة تنازليًا",
    "answer_2": "عناصر مرتبة تصاعديًا",
    "answer_3": "العناصر حسب الإدخال",
    "answer_4": "العناصر بشكل عشوائي",
    "correct_ans": "عناصر مرتبة تصاعديًا"
  },
  {
    "title": "أي نوع العبور يزور العقدة قبل أبنائها في BST؟",
    "answer_1": "Inorder",
    "answer_2": "Postorder",
    "answer_3": "Preorder",
    "answer_4": "Level Order",
    "correct_ans": "Preorder"
  },
  {
    "title": "في العبور من نوع Postorder، متى تتم زيارة العقدة؟",
    "answer_1": "قبل زيارة الأبناء",
    "answer_2": "بين الابن الأيسر والأيمن",
    "answer_3": "بعد زيارة الأبناء",
    "answer_4": "فقط عند كونها جذر",
    "correct_ans": "بعد زيارة الأبناء"
  },
  {
    "title": "عند حذف عقدة لها ابن واحد في BST، ماذا يحدث؟",
    "answer_1": "يتم حذف كامل الشجرة",
    "answer_2": "يتم ربط الأب مباشرة بالابن",
    "answer_3": "يتم تجاهل العقدة",
    "answer_4": "يتم استبدالها بالجذر",
    "correct_ans": "يتم ربط الأب مباشرة بالابن"
  },
  {
    "title": "عند حذف عقدة لها ابنان في BST، أي عنصر يُستخدم للاستبدال ؟",
    "answer_1": "أكبر عنصر في الفرع الأيسر",
    "answer_2": "أصغر عنصر في الفرع الأيمن",
    "answer_3": "الجذر دائمًا",
    "answer_4": "أقرب عقدة ورقية",
    "correct_ans": "أصغر عنصر في الفرع الأيمن"
  },
  {
    "title": "ما القيمة الابتدائية للمؤشر المستخدم للبحث عن عقدة داخل BST ؟",
    "answer_1": "NULL",
    "answer_2": "الجذر",
    "answer_3": "أول عقدة مدخلة",
    "answer_4": "الفرع الأيسر",
    "correct_ans": "الجذر"
  },
  {
    "title": "أثناء البحث في BST، ماذا يحدث إذا كانت القيمة المطلوبة أكبر من قيمة العقدة الحالية؟",
    "answer_1": "ننتقل إلى الفرع الأيسر",
    "answer_2": "ننتقل إلى الفرع الأيمن",
    "answer_3": "نعود إلى الجذر",
    "answer_4": "نُنهي البحث مباشرة",
    "correct_ans": "ننتقل إلى الفرع الأيمن"
  },
  {
    "title": "في كود البحث باستخدام while، ما الشرط الأساسي لاستمرار الحلقة؟",
    "answer_1": "طالما العقدة الحالية ليست ورقية",
    "answer_2": "طالما المؤشر لا يساوي NULL والقيمة غير موجودة",
    "answer_3": "طالما القيمة أكبر من الجذر",
    "answer_4": "طالما الشجرة غير فارغة",
    "correct_ans": "طالما المؤشر لا يساوي NULL والقيمة غير موجودة"
  },
  {
    "title": "ماذا يعني وصول المؤشر إلى NULL أثناء عملية البحث في BST؟",
    "answer_1": "العقدة موجودة",
    "answer_2": "القيمة غير موجودة في الشجرة",
    "answer_3": "تم الوصول إلى الجذر",
    "answer_4": "يجب إعادة الإدخال",
    "correct_ans": "القيمة غير موجودة في الشجرة"
  },
  {
    "title": "في العبور من نوع Preorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "يسار - عقدة - يمين",
    "answer_2": "يسار - يمين - عقدة",
    "answer_3": "عقدة - يسار - يمين",
    "answer_4": "يمين - عقدة - يسار",
    "correct_ans": "عقدة - يسار - يمين"
  },
  {
    "title": "في العبور من نوع Inorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "عقدة - يسار - يمين",
    "answer_2": "يسار - عقدة - يمين",
    "answer_3": "يمين - عقدة - يسار",
    "answer_4": "يسار - يمين - عقدة",
    "correct_ans": "يسار - عقدة - يمين"
  },
  {
    "title": "في العبور من نوع Postorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "عقدة - يسار - يمين",
    "answer_2": "يسار - عقدة - يمين",
    "answer_3": "يسار - يمين - عقدة",
    "answer_4": "يمين - عقدة - يسار",
    "correct_ans": "يسار - يمين - عقدة"
  },
  {
    "title": "أثناء حذف عقدة لها ابنان في BST، لماذا نبحث عن أصغر عنصر في الفرع الأيمن؟",
    "answer_1": "لأنه الجذر الجديد دائمًا",
    "answer_2": "للحفاظ على خاصية BST بعد الاستبدال",
    "answer_3": "لأنه أسرع عنصر وصولًا",
    "answer_4": "لأنه عقدة ورقية دائمًا",
    "correct_ans": "للحفاظ على خاصية BST بعد الاستبدال"
  },
  {
    "title": "بعد استبدال قيمة عقدة لها ابنان، ما الخطوة التالية في الحذف؟",
    "answer_1": "إنهاء العملية",
    "answer_2": "حذف العقدة البديلة من موقعها الأصلي",
    "answer_3": "إعادة بناء الشجرة كاملة",
    "answer_4": "نقل الجذر",
    "correct_ans": "حذف العقدة البديلة من موقعها الأصلي"
  },
  {
    "title": "في حال كانت العقدة المراد حذفها هي الجذر وليس لها أبناء، ماذا يحدث؟",
    "answer_1": "تبقى الشجرة كما هي",
    "answer_2": "يصبح الجذر NULL",
    "answer_3": "يتم استبدالها بابنها الأيسر",
    "answer_4": "يتم استبدالها بأصغر عنصر في اليمين",
    "correct_ans": "يصبح الجذر NULL"
  },
  {
    "title": "في عملية البحث داخل BST، ما دور المؤشر الذي يحتفظ بالعقدة السابقة (الأب) أثناء التنقل؟",
    "answer_1": "تخزين قيمة الجذر",
    "answer_2": "المساعدة في الربط عند الحذف",
    "answer_3": "تحديد نوع العبور",
    "answer_4": "إنهاء البحث",
    "correct_ans": "المساعدة في الربط عند الحذف"
  },
  {
    "title": "أثناء الحذف، لماذا نحتاج إلى معرفة ما إذا كانت العقدة المحذوفة ابنًا أيسر أم أيمن؟",
    "answer_1": "لتحديد نوع العبور",
    "answer_2": "لربط الأب بالفرع الصحيح",
    "answer_3": "لتحديث قيمة الجذر",
    "answer_4": "لإنهاء العملية",
    "correct_ans": "لربط الأب بالفرع الصحيح"
  },
  {
    "title": "في كود الحذف، ماذا يحدث إذا كانت العقدة المراد حذفها ورقية (Leaf)؟",
    "answer_1": "يتم استبدالها بعقدة أخرى",
    "answer_2": "يتم حذفها وجعل مؤشر الأب يشير إلى NULL",
    "answer_3": "يتم تجاهل الحذف",
    "answer_4": "يتم نقلها إلى الجذر",
    "correct_ans": "يتم حذفها وجعل مؤشر الأب يشير إلى NULL"
  },
  {
    "title": "في حالة حذف عقدة لها ابن واحد فقط، إلى ماذا يجب أن يشير الأب بعد الحذف؟",
    "answer_1": "إلى NULL",
    "answer_2": "إلى الجذر",
    "answer_3": "إلى الابن الوحيد للعقدة المحذوفة",
    "answer_4": "إلى أصغر عنصر في الشجرة",
    "correct_ans": "إلى الابن الوحيد للعقدة المحذوفة"
  },
  {
    "title": "أثناء البحث عن أصغر عنصر في الفرع الأيمن، كيف نصل إليه ؟",
    "answer_1": "بالانتقال دائمًا إلى اليمين",
    "answer_2": "بالانتقال دائمًا إلى اليسار",
    "answer_3": "بالعودة إلى الجذر",
    "answer_4": "باستخدام العبور من نوع Inorder",
    "correct_ans": "بالانتقال دائمًا إلى اليسار"
  },
  {
    "title": "ما الحالة التي تتطلب حذف العقدة البديلة بعد استبدال القيمة أثناء الحذف؟",
    "answer_1": "عند حذف عقدة ورقية",
    "answer_2": "عند حذف عقدة لها ابن واحد",
    "answer_3": "عند حذف عقدة لها ابنان",
    "answer_4": "عند حذف الجذر فقط",
    "correct_ans": "عند حذف عقدة لها ابنان"
  },
  {
    "title": "في كود الحذف، لماذا لا يتم حذف العقدة ذات الابنين مباشرة؟",
    "answer_1": "لأنها الجذر",
    "answer_2": "لأن حذفها مباشرة يكسر خاصية BST",
    "answer_3": "لأنها عقدة ورقية",
    "answer_4": "لأنها لا تحتوي قيمة",
    "correct_ans": "لأن حذفها مباشرة يكسر خاصية BST"
  },
  {
    "title": "ما النتيجة إذا حاولنا حذف قيمة غير موجودة في BST حسب منطق البحث؟",
    "answer_1": "يتم حذف الجذر",
    "answer_2": "تنتهي العملية دون أي تعديل",
    "answer_3": "يتم إدخال القيمة بدل حذفها",
    "answer_4": "تُعاد بناء الشجرة",
    "correct_ans": "تنتهي العملية دون أي تعديل"
  },
  {
    "title": "في حال كانت الشجرة فارغة، ماذا يحدث عند محاولة الحذف؟",
    "answer_1": "يتم إنشاء عقدة جديدة",
    "answer_2": "يتم الوصول إلى NULL مباشرة",
    "answer_3": "يتم حذف الجذر",
    "answer_4": "تُنفذ العبور",
    "correct_ans": "يتم الوصول إلى NULL مباشرة"
  },
  {
    "title": "لماذا يتم تنفيذ عملية البحث قبل أي حذف في BST؟",
    "answer_1": "لتحديد نوع العبور",
    "answer_2": "للتأكد من وجود العقدة وتحديد موقعها",
    "answer_3": "لإعادة ترتيب الشجرة",
    "answer_4": "لتحديد عدد الأبناء",
    "correct_ans": "للتأكد من وجود العقدة وتحديد موقعها"
  },
  {
    "title": "في كود الإدخال إلى BST، ماذا يحدث إذا كانت الشجرة فارغة؟",
    "answer_1": "يتم تجاهل الإدخال",
    "answer_2": "تُنشأ عقدة جديدة وتصبح الجذر",
    "answer_3": "يتم الانتقال إلى الفرع الأيسر",
    "answer_4": "يتم تنفيذ العبور",
    "correct_ans": "تُنشأ عقدة جديدة وتصبح الجذر"
  },
  {
    "title": "أثناء الإدخال، متى تتوقف عملية التنقل داخل BST؟",
    "answer_1": "عند الوصول إلى الجذر",
    "answer_2": "عند الوصول إلى عقدة لها ابنان",
    "answer_3": "عند الوصول إلى مؤشر NULL",
    "answer_4": "عند مقارنة أول عقدة فقط",
    "correct_ans": "عند الوصول إلى مؤشر NULL"
  },
  {
    "title": "في كود الإدخال، لماذا نحتفظ بمؤشر للعقدة السابقة أثناء التنقل؟",
    "answer_1": "لتحديد نوع العبور",
    "answer_2": "لربط العقدة الجديدة في المكان الصحيح",
    "answer_3": "لتحديث قيمة الجذر",
    "answer_4": "لإنهاء العملية",
    "correct_ans": "لربط العقدة الجديدة في المكان الصحيح"
  },
  {
    "title": "في BST إذا كانت القيمة المُدخلة مساوية لقيمة عقدة موجودة، ماذا يحدث ؟",
    "answer_1": "يتم إدخالها في الفرع الأيسر",
    "answer_2": "يتم إدخالها في الفرع الأيمن",
    "answer_3": "لا يتم الإدخال",
    "answer_4": "يتم استبدال العقدة القديمة",
    "correct_ans": "لا يتم الإدخال"
  },
  {
    "title": "في العبور، ما الشرط الأساسي للاستدعاء التراجعي؟",
    "answer_1": "أن تكون العقدة جذر",
    "answer_2": "أن لا تكون العقدة NULL",
    "answer_3": "أن تكون العقدة ورقية",
    "answer_4": "أن يكون لها أبناء",
    "correct_ans": "أن لا تكون العقدة NULL"
  },
  {
    "title": "ماذا يحدث إذا تم تنفيذ العبور على شجرة فارغة؟",
    "answer_1": "يتم طباعة NULL",
    "answer_2": "لا يتم تنفيذ أي شيء",
    "answer_3": "يحدث خطأ",
    "answer_4": "يتم إنشاء جذر تلقائيًا",
    "correct_ans": "لا يتم تنفيذ أي شيء"
  },
  {
    "title": "في كود الحذف، لماذا يتم التعامل مع حذف الجذر كحالة خاصة؟",
    "answer_1": "لأن الجذر لا يملك أبًا",
    "answer_2": "لأن الجذر دائمًا له ابنان",
    "answer_3": "لأن الجذر لا يمكن حذفه",
    "answer_4": "لأن الجذر يُحذف آخرًا",
    "correct_ans": "لأن الجذر لا يملك أبًا"
  },
  {
    "title": "أثناء حذف الجذر وله ابن واحد فقط، ماذا يصبح الجذر الجديد؟",
    "answer_1": "NULL",
    "answer_2": "الابن الوحيد للجذر",
    "answer_3": "أصغر عنصر في الشجرة",
    "answer_4": "يبقى كما هو",
    "correct_ans": "الابن الوحيد للجذر"
  },
  {
    "title": "ما الذي يضمن بقاء خاصية BST صحيحة بعد أي عملية إدخال أو حذف؟",
    "answer_1": "تنفيذ العبور",
    "answer_2": "الالتزام بشروط المقارنة والربط",
    "answer_3": "إعادة بناء الشجرة",
    "answer_4": "ترتيب العناصر يدويًا",
    "correct_ans": "الالتزام بشروط المقارنة والربط"
  },
  {
    "title": "عند إدخال أول عنصر في BST، ما موقعه في الشجرة؟",
    "answer_1": "الفرع الأيسر",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الجذر",
    "answer_4": "لا يتم إدخاله",
    "correct_ans": "الجذر"
  },
  {
    "title": "أثناء الإدخال، ما الشرط الذي يحدد الانتقال إلى الفرع الأيسر؟",
    "answer_1": "القيمة أكبر من العقدة الحالية",
    "answer_2": "القيمة أصغر من العقدة الحالية",
    "answer_3": "القيمة مساوية",
    "answer_4": "العقدة NULL",
    "correct_ans": "القيمة أصغر من العقدة الحالية"
  },
  {
    "title": "في كود الإدخال، ماذا يعني أن نصل إلى مؤشر NULL؟",
    "answer_1": "القيمة موجودة",
    "answer_2": "مكان مناسب لإدخال عقدة جديدة",
    "answer_3": "يجب إيقاف الإدخال",
    "answer_4": "الشجرة فارغة",
    "correct_ans": "مكان مناسب لإدخال عقدة جديدة"
  },
  {
    "title": "ما الهدف من مقارنة القيم أثناء عملية الإدخال في BST؟",
    "answer_1": "تحديد نوع العبور",
    "answer_2": "المحافظة على خاصية BST",
    "answer_3": "تسريع التنفيذ",
    "answer_4": "تقليل الذاكرة",
    "correct_ans": "المحافظة على خاصية BST"
  },
  {
    "title": "أثناء البحث، ما القيمة الابتدائية للمؤشر المستخدم للتنقل؟",
    "answer_1": "NULL",
    "answer_2": "الجذر",
    "answer_3": "أول عقدة مدخلة",
    "answer_4": "الفرع الأيسر",
    "correct_ans": "الجذر"
  },
  {
    "title": "في العبور من نوع Inorder، ما أول جزء يتم زيارته؟",
    "answer_1": "العقدة",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الفرع الأيسر",
    "answer_4": "الجذر فقط",
    "correct_ans": "الفرع الأيسر"
  },
  {
    "title": "ما الشرط الأساسي لتنفيذ العبور تراجعيًا؟",
    "answer_1": "أن تكون العقدة ورقية",
    "answer_2": "أن لا تكون العقدة NULL",
    "answer_3": "أن تكون العقدة جذر",
    "answer_4": "أن تحتوي قيمة موجبة",
    "correct_ans": "أن لا تكون العقدة NULL"
  },
  {
    "title": "في العبور من نوع Preorder، متى تتم زيارة الجذر؟",
    "answer_1": "بعد الأبناء",
    "answer_2": "قبل الأبناء",
    "answer_3": "بين الأبناء",
    "answer_4": "لا يتم زيارته",
    "correct_ans": "قبل الأبناء"
  },
  {
    "title": "في العبور من نوع Postorder، متى تتم زيارة العقدة؟",
    "answer_1": "قبل الأبناء",
    "answer_2": "بعد الأبناء",
    "answer_3": "بين الأبناء",
    "answer_4": "عند كونها جذر فقط",
    "correct_ans": "بعد الأبناء"
  },
  {
    "title": "ما أول خطوة يتم تنفيذها قبل حذف أي عقدة في BST؟",
    "answer_1": "العبور",
    "answer_2": "البحث عن العقدة",
    "answer_3": "إعادة بناء الشجرة",
    "answer_4": "حذف الجذر",
    "correct_ans": "البحث عن العقدة"
  },
  {
    "title": "عند حذف عقدة ورقية، ماذا يحدث لمؤشر الأب؟",
    "answer_1": "يبقى كما هو",
    "answer_2": "يشير إلى NULL",
    "answer_3": "يشير إلى الجذر",
    "answer_4": "يشير إلى الابن الأيمن",
    "correct_ans": "يشير إلى NULL"
  },
  {
    "title": "في حالة حذف عقدة لها ابن واحد، كيف يتم الربط؟",
    "answer_1": "الأب يشير إلى NULL",
    "answer_2": "الأب يشير إلى الابن الوحيد",
    "answer_3": "الابن يشير إلى الجذر",
    "answer_4": "يتم حذف الشجرة",
    "correct_ans": "الأب يشير إلى الابن الوحيد"
  },
  {
    "title": "في حذف عقدة لها ابنان، من أين نبدأ البحث عن العقدة البديلة؟",
    "answer_1": "الفرع الأيسر",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الجذر",
    "answer_4": "العقدة نفسها",
    "correct_ans": "الفرع الأيمن"
  },
  {
    "title": "كيف نصل إلى أصغر عنصر في الفرع الأيمن أثناء الحذف؟",
    "answer_1": "بالانتقال يمينًا دائمًا",
    "answer_2": "بالانتقال يسارًا دائمًا",
    "answer_3": "باستخدام العبور",
    "answer_4": "بالعودة للجذر",
    "correct_ans": "بالانتقال يسارًا دائمًا"
  },
  {
    "title": "بعد استبدال قيمة العقدة المحذوفة، ما الخطوة التالية؟",
    "answer_1": "إنهاء العملية",
    "answer_2": "حذف العقدة البديلة من مكانها",
    "answer_3": "إعادة بناء الشجرة",
    "answer_4": "تنفيذ العبور",
    "correct_ans": "حذف العقدة البديلة من مكانها"
  },
  {
    "title": "لماذا يتم التعامل مع حذف الجذر كحالة خاصة؟",
    "answer_1": "لأنه دائمًا له ابنان",
    "answer_2": "لأنه لا يملك أبًا",
    "answer_3": "لأنه لا يمكن حذفه",
    "answer_4": "لأنه أول عقدة مدخلة",
    "correct_ans": "لأنه لا يملك أبًا"
  },
  {
    "title": "إذا كانت الشجرة فارغة، ماذا يحدث عند تنفيذ البحث؟",
    "answer_1": "يتم الوصول إلى NULL مباشرة",
    "answer_2": "يتم إنشاء جذر",
    "answer_3": "يتم تنفيذ العبور",
    "answer_4": "يحدث خطأ",
    "correct_ans": "يتم الوصول إلى NULL مباشرة"
  },
  {
    "title": "ما الذي يمنع إدخال قيمة مكررة في BST ؟",
    "answer_1": "العبور",
    "answer_2": "شرط المقارنة أثناء الإدخال",
    "answer_3": "الحذف",
    "answer_4": "كونها شجرة كاملة",
    "correct_ans": "شرط المقارنة أثناء الإدخال"
  },
  {
    "title": "ما الذي يضمن بقاء ترتيب BST صحيحًا بعد الإدخال أو الحذف؟",
    "answer_1": "إعادة ترتيب العناصر",
    "answer_2": "الالتزام بقواعد المقارنة والربط",
    "answer_3": "العبور",
    "answer_4": "حذف القيم الكبيرة",
    "correct_ans": "الالتزام بقواعد المقارنة والربط"
  },
  {
    "title": "ماذا يحدث إذا حاولنا البحث عن قيمة في BST وكانت الشجرة فارغة؟",
    "answer_1": "يتم العثور على القيمة",
    "answer_2": "يتم الوصول مباشرة إلى NULL",
    "answer_3": "يتم إنشاء جذر جديد",
    "answer_4": "يتم تنفيذ العبور",
    "correct_ans": "يتم الوصول مباشرة إلى NULL"
  },
  {
    "title": "ما نتيجة نسيان تحديث مؤشر الأب أثناء عملية الحذف في BST؟",
    "answer_1": "لا يحدث أي تأثير",
    "answer_2": "انقطاع الربط الصحيح في الشجرة",
    "answer_3": "زيادة سرعة التنفيذ",
    "answer_4": "تحسن العبور",
    "correct_ans": "انقطاع الربط الصحيح في الشجرة"
  },
  {
    "title": "أي تصرّف يؤدي إلى كسر خاصية BST أثناء الإدخال؟",
    "answer_1": "الانتقال يسارًا عند قيمة أصغر",
    "answer_2": "الانتقال يمينًا عند قيمة أكبر",
    "answer_3": "إدخال قيمة أكبر في الفرع الأيسر",
    "answer_4": "التوقف عند NULL",
    "correct_ans": "إدخال قيمة أكبر في الفرع الأيسر"
  },
  {
    "title": "ما نتيجة تنفيذ العبور على عقدة قيمتها NULL؟",
    "answer_1": "يتم طباعة NULL",
    "answer_2": "لا يتم تنفيذ أي شيء",
    "answer_3": "يتم حذف العقدة",
    "answer_4": "يحدث خطأ",
    "correct_ans": "لا يتم تنفيذ أي شيء"
  },
  {
    "title": "أثناء حذف عقدة لها ابنان، ما الخطأ إذا لم نحذف العقدة البديلة من مكانها الأصلي؟",
    "answer_1": "لا يحدث أي تأثير",
    "answer_2": "تتكرر القيمة في الشجرة",
    "answer_3": "تُحذف الشجرة كاملة",
    "answer_4": "يتم فقدان الجذر",
    "correct_ans": "تتكرر القيمة في الشجرة"
  },
  {
    "title": "أي خطوة يجب تنفيذها مباشرة بعد الوصول إلى NULL أثناء الإدخال؟",
    "answer_1": "إنهاء البرنامج",
    "answer_2": "تنفيذ العبور",
    "answer_3": "إنشاء عقدة جديدة وربطها",
    "answer_4": "العودة للجذر",
    "correct_ans": "إنشاء عقدة جديدة وربطها"
  },
  {
    "title": "ما نتيجة حذف عقدة غير موجودة في BST؟",
    "answer_1": "يتم حذف الجذر",
    "answer_2": "تنتهي العملية دون أي تعديل",
    "answer_3": "يتم إدخال القيمة",
    "answer_4": "تُعاد بناء الشجرة",
    "correct_ans": "تنتهي العملية دون أي تعديل"
  },
  {
    "title": "أي تصرّف صحيح عند حذف الجذر وله ابن واحد فقط؟",
    "answer_1": "جعل الجذر NULL دائمًا",
    "answer_2": "ربط الجذر بالابن الوحيد",
    "answer_3": "استبداله بأصغر عنصر في اليمين",
    "answer_4": "منع الحذف",
    "correct_ans": "ربط الجذر بالابن الوحيد"
  },
  {
    "title": "ما سبب التعامل مع حذف الجذر كحالة خاصة في الكود؟",
    "answer_1": "لأنه دائمًا ورقي",
    "answer_2": "لأنه لا يملك أبًا",
    "answer_3": "لأنه آخر عقدة",
    "answer_4": "لأنه لا يُحذف",
    "correct_ans": "لأنه لا يملك أبًا"
  }
]