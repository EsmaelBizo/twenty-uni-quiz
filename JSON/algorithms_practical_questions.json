[
  {
    "title": "أي مما يلي لا يمكن أن يكون نتيجة مباشرة لعملية Partitioning واحدة؟",
    "answer_1": "وجود عناصر أصغر من المحور في جهة واحدة",
    "answer_2": "وجود عناصر أكبر من المحور في الجهة المقابلة",
    "answer_3": "ترتيب كامل لجميع عناصر المصفوفة",
    "answer_4": "تحديد نقطة فصل بين قسمين",
    "correct_ans": "ترتيب كامل لجميع عناصر المصفوفة"
  },
  {
    "title": "لماذا تُطبّق QuickSort تراجعيًا على الأقسام الناتجة بعد Partitioning؟",
    "answer_1": "لأن العناصر أصبحت عشوائية",
    "answer_2": "لأن كل قسم يمثل مشكلة أصغر من نفس النوع",
    "answer_3": "لأن المحور قد يتغير",
    "answer_4": "لأن المصفوفة لم تعد صالحة",
    "correct_ans": "لأن كل قسم يمثل مشكلة أصغر من نفس النوع"
  },
  {
    "title": "في حال تم اختيار محور غير مناسب بشكل متكرر، ما الأثر المتوقع على تنفيذ QuickSort؟",
    "answer_1": "توقف الخوارزمية",
    "answer_2": "زيادة عدد خطوات التقسيم والاستدعاء",
    "answer_3": "الحصول على ترتيب خاطئ",
    "answer_4": "عدم تنفيذ Partitioning",
    "correct_ans": "زيادة عدد خطوات التقسيم والاستدعاء"
  },
  {
    "title": "متى نعتبر أن QuickSort أنهى ترتيب المصفوفة بالكامل؟",
    "answer_1": "بعد تنفيذ أول Partitioning",
    "answer_2": "بعد ترتيب جميع الأقسام الناتجة",
    "answer_3": "عند اختيار محور مناسب",
    "answer_4": "عند تساوي جميع العناصر",
    "correct_ans": "بعد ترتيب جميع الأقسام الناتجة"
  },
  {
    "title": "ما الهدف الأساسي من خوارزمية QuickSort؟",
    "answer_1": "تقليل عدد العناصر",
    "answer_2": "ترتيب العناصر باستخدام التقسيم والاستدعاء التراجعي",
    "answer_3": "البحث عن عنصر محدد",
    "answer_4": "دمج مصفوفتين",
    "correct_ans": "ترتيب العناصر باستخدام التقسيم والاستدعاء التراجعي"
  },
  {
    "title": "ما النتيجة المباشرة لعملية Partitioning في QuickSort؟",
    "answer_1": "ترتيب كامل للمصفوفة",
    "answer_2": "تقسيم العناصر إلى قسمين بالنسبة لمحور",
    "answer_3": "اختيار أصغر عنصر",
    "answer_4": "إلغاء الاستدعاء التراجعي",
    "correct_ans": "تقسيم العناصر إلى قسمين بالنسبة لمحور"
  },
  {
    "title": "أي عبارة تصف حالة العناصر بعد تنفيذ Partitioning مباشرة؟",
    "answer_1": "العناصر مرتبة بالكامل",
    "answer_2": "كل العناصر الأصغر من المحور في جهة واحدة",
    "answer_3": "العناصر موزعة عشوائيًا",
    "answer_4": "العناصر الأكبر في اليسار دائمًا",
    "correct_ans": "كل العناصر الأصغر من المحور في جهة واحدة"
  },
  {
    "title": "أي حالة تجعل QuickSort يتوقف عن الاستدعاء التراجعي؟",
    "answer_1": "عند تساوي جميع العناصر",
    "answer_2": "عندما يصبح القسم بطول صفر أو واحد",
    "answer_3": "عند اختيار محور جيد",
    "answer_4": "بعد أول تقسيم",
    "correct_ans": "عندما يصبح القسم بطول صفر أو واحد"
  },
  {
    "title": "لماذا يُعتبر QuickSort خوارزمية Divide and Conquer؟",
    "answer_1": "لأنه يستخدم مصفوفة إضافية",
    "answer_2": "لأنه يقسم المشكلة إلى مشاكل أصغر ثم يحلها",
    "answer_3": "لأنه يعمل بدون recursion",
    "answer_4": "لأنه يعتمد على الدمج",
    "correct_ans": "لأنه يقسم المشكلة إلى مشاكل أصغر ثم يحلها"
  },
  {
    "title": "أي ميزة لـ QuickSort تميزها عن MergeSort؟",
    "answer_1": "لا يستخدم recursion",
    "answer_2": "لا يحتاج خطوة دمج",
    "answer_3": "أبطأ دائمًا",
    "answer_4": "يستخدم ذاكرة إضافية",
    "correct_ans": "لا يحتاج خطوة دمج"
  },
  {
    "title": "ما الهدف من استخدام مؤشرين يتحركان من جهتين متعاكستين في خوارزمية QuickSort؟",
    "answer_1": "لتقليل عدد العناصر",
    "answer_2": "لتقسيم العناصر بالنسبة للمحور",
    "answer_3": "لتسريع الاستدعاء التراجعي",
    "answer_4": "لتفادي استخدام recursion",
    "correct_ans": "لتقسيم العناصر بالنسبة للمحور"
  },
  {
    "title": "لماذا لا نعيد معالجة عنصر المحور بعد تنفيذ Partitioning؟",
    "answer_1": "لأنه حُذف من المصفوفة",
    "answer_2": "لأنه أصبح في موقعه الصحيح",
    "answer_3": "لأنه أكبر عنصر",
    "answer_4": "لأنه لا يؤثر على النتيجة",
    "correct_ans": "لأنه أصبح في موقعه الصحيح"
  },
  {
    "title": "ما الخطأ المنطقي إذا استمر الاستدعاء التراجعي بدون شروط إيقاف صحيحة في QuickSort؟",
    "answer_1": "ترتيب غير صحيح",
    "answer_2": "حلقة لا نهائية أو استدعاءات زائدة",
    "answer_3": "تجاهل بعض العناصر",
    "answer_4": "زيادة الذاكرة فقط",
    "correct_ans": "حلقة لا نهائية أو استدعاءات زائدة"
  },
  {
    "title": "في Binary Search Tree، عند إدخال قيمة أصغر من قيمة العقدة الحالية، إلى أي فرع ننتقل؟",
    "answer_1": "الفرع الأيمن",
    "answer_2": "الفرع الأيسر",
    "answer_3": "الجذر مباشرة",
    "answer_4": "نتوقف عن الإدخال",
    "correct_ans": "الفرع الأيسر"
  },
  {
    "title": "في عملية البحث عن قيمة داخل BST باستخدام حلقة while، متى تتوقف الحلقة؟",
    "answer_1": "عند الوصول إلى عقدة ورقية فقط",
    "answer_2": "عند العثور على القيمة أو الوصول إلى NULL",
    "answer_3": "عند مقارنة أول عقدة فقط",
    "answer_4": "عند الانتقال إلى الفرع الأيمن",
    "correct_ans": "عند العثور على القيمة أو الوصول إلى NULL"
  },
  {
    "title": "ما نتيجة تنفيذ العبور من نوع Inorder على Binary Search Tree؟",
    "answer_1": "عناصر مرتبة تنازليًا",
    "answer_2": "عناصر مرتبة تصاعديًا",
    "answer_3": "العناصر حسب الإدخال",
    "answer_4": "العناصر بشكل عشوائي",
    "correct_ans": "عناصر مرتبة تصاعديًا"
  },
  {
    "title": "أي نوع العبور يزور العقدة قبل أبنائها في BST؟",
    "answer_1": "Inorder",
    "answer_2": "Postorder",
    "answer_3": "Preorder",
    "answer_4": "Level Order",
    "correct_ans": "Preorder"
  },
  {
    "title": "في العبور من نوع Postorder، متى تتم زيارة العقدة؟",
    "answer_1": "قبل زيارة الأبناء",
    "answer_2": "بين الابن الأيسر والأيمن",
    "answer_3": "بعد زيارة الأبناء",
    "answer_4": "فقط عند كونها جذر",
    "correct_ans": "بعد زيارة الأبناء"
  },
  {
    "title": "عند حذف عقدة لها ابن واحد في BST، ماذا يحدث؟",
    "answer_1": "يتم حذف كامل الشجرة",
    "answer_2": "يتم ربط الأب مباشرة بالابن",
    "answer_3": "يتم تجاهل العقدة",
    "answer_4": "يتم استبدالها بالجذر",
    "correct_ans": "يتم ربط الأب مباشرة بالابن"
  },
  {
    "title": "عند حذف عقدة لها ابنان في BST، أي عنصر يُستخدم للاستبدال ؟",
    "answer_1": "أكبر عنصر في الفرع الأيسر",
    "answer_2": "أصغر عنصر في الفرع الأيمن",
    "answer_3": "الجذر دائمًا",
    "answer_4": "أقرب عقدة ورقية",
    "correct_ans": "أصغر عنصر في الفرع الأيمن"
  },
  {
    "title": "ما القيمة الابتدائية للمؤشر المستخدم للبحث عن عقدة داخل BST ؟",
    "answer_1": "NULL",
    "answer_2": "الجذر",
    "answer_3": "أول عقدة مدخلة",
    "answer_4": "الفرع الأيسر",
    "correct_ans": "الجذر"
  },
  {
    "title": "أثناء البحث في BST، ماذا يحدث إذا كانت القيمة المطلوبة أكبر من قيمة العقدة الحالية؟",
    "answer_1": "ننتقل إلى الفرع الأيسر",
    "answer_2": "ننتقل إلى الفرع الأيمن",
    "answer_3": "نعود إلى الجذر",
    "answer_4": "نُنهي البحث مباشرة",
    "correct_ans": "ننتقل إلى الفرع الأيمن"
  },
  {
    "title": "ماذا يعني وصول المؤشر إلى NULL أثناء عملية البحث في BST؟",
    "answer_1": "العقدة موجودة",
    "answer_2": "القيمة غير موجودة في الشجرة",
    "answer_3": "تم الوصول إلى الجذر",
    "answer_4": "يجب إعادة الإدخال",
    "correct_ans": "القيمة غير موجودة في الشجرة"
  },
  {
    "title": "في العبور من نوع Preorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "يسار - عقدة - يمين",
    "answer_2": "يسار - يمين - عقدة",
    "answer_3": "عقدة - يسار - يمين",
    "answer_4": "يمين - عقدة - يسار",
    "correct_ans": "عقدة - يسار - يمين"
  },
  {
    "title": "في العبور من نوع Inorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "عقدة - يسار - يمين",
    "answer_2": "يسار - عقدة - يمين",
    "answer_3": "يمين - عقدة - يسار",
    "answer_4": "يسار - يمين - عقدة",
    "correct_ans": "يسار - عقدة - يمين"
  },
  {
    "title": "في العبور من نوع Postorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "عقدة - يسار - يمين",
    "answer_2": "يسار - عقدة - يمين",
    "answer_3": "يسار - يمين - عقدة",
    "answer_4": "يمين - عقدة - يسار",
    "correct_ans": "يسار - يمين - عقدة"
  },
  {
    "title": "أثناء حذف عقدة لها ابنان في BST، لماذا نبحث عن أصغر عنصر في الفرع الأيمن؟",
    "answer_1": "لأنه الجذر الجديد دائمًا",
    "answer_2": "للحفاظ على خاصية BST بعد الاستبدال",
    "answer_3": "لأنه أسرع عنصر وصولًا",
    "answer_4": "لأنه عقدة ورقية دائمًا",
    "correct_ans": "للحفاظ على خاصية BST بعد الاستبدال"
  },
  {
    "title": "في BST بعد استبدال قيمة عقدة لها ابنان، ما الخطوة التالية في الحذف؟",
    "answer_1": "إنهاء العملية",
    "answer_2": "حذف العقدة البديلة من موقعها الأصلي",
    "answer_3": "إعادة بناء الشجرة كاملة",
    "answer_4": "نقل الجذر",
    "correct_ans": "حذف العقدة البديلة من موقعها الأصلي"
  },
  {
    "title": "في خوارزمية BST في حال كانت العقدة المراد حذفها هي الجذر وليس لها أبناء، ماذا يحدث؟",
    "answer_1": "تبقى الشجرة كما هي",
    "answer_2": "يصبح الجذر NULL",
    "answer_3": "يتم استبدالها بابنها الأيسر",
    "answer_4": "يتم استبدالها بأصغر عنصر في اليمين",
    "correct_ans": "يصبح الجذر NULL"
  },
  {
    "title": "في عملية البحث داخل BST، ما دور المؤشر الذي يحتفظ بالعقدة السابقة (الأب) أثناء التنقل؟",
    "answer_1": "تخزين قيمة الجذر",
    "answer_2": "المساعدة في الربط عند الحذف",
    "answer_3": "تحديد نوع العبور",
    "answer_4": "إنهاء البحث",
    "correct_ans": "المساعدة في الربط عند الحذف"
  },
  {
    "title": "في BST في كود الحذف، ماذا يحدث إذا كانت العقدة المراد حذفها ورقية (Leaf)؟",
    "answer_1": "يتم استبدالها بعقدة أخرى",
    "answer_2": "يتم حذفها وجعل مؤشر الأب يشير إلى NULL",
    "answer_3": "يتم تجاهل الحذف",
    "answer_4": "يتم نقلها إلى الجذر",
    "correct_ans": "يتم حذفها وجعل مؤشر الأب يشير إلى NULL"
  },
  {
    "title": "في BST في حالة حذف عقدة لها ابن واحد فقط، إلى ماذا يجب أن يشير الأب بعد الحذف؟",
    "answer_1": "إلى NULL",
    "answer_2": "إلى الجذر",
    "answer_3": "إلى الابن الوحيد للعقدة المحذوفة",
    "answer_4": "إلى أصغر عنصر في الشجرة",
    "correct_ans": "إلى الابن الوحيد للعقدة المحذوفة"
  },
  {
    "title": "في BST أثناء البحث عن أصغر عنصر في الفرع الأيمن، كيف نصل إليه ؟",
    "answer_1": "بالانتقال دائمًا إلى الابن الأيمن",
    "answer_2": "بالانتقال دائمًا إلى الابن الأيسر",
    "answer_3": "بالعودة إلى الجذر",
    "answer_4": "باستخدام العبور من نوع Inorder",
    "correct_ans": "بالانتقال دائمًا إلى الابن الأيسر"
  },
  {
    "title": "في BST ما الحالة التي تتطلب حذف العقدة البديلة بعد استبدال القيمة أثناء الحذف؟",
    "answer_1": "عند حذف عقدة ورقية",
    "answer_2": "عند حذف عقدة لها ابن واحد",
    "answer_3": "عند حذف عقدة لها ابنان",
    "answer_4": "عند حذف الجذر فقط",
    "correct_ans": "عند حذف عقدة لها ابنان"
  },
  {
    "title": "في كود الحذف في BST ، لماذا لا يتم حذف العقدة ذات الابنين مباشرة؟",
    "answer_1": "لأنها الجذر",
    "answer_2": "لأن حذفها مباشرة يكسر خاصية BST",
    "answer_3": "لأنها عقدة ورقية",
    "answer_4": "لأنها لا تحتوي قيمة",
    "correct_ans": "لأن حذفها مباشرة يكسر خاصية BST"
  },
  {
    "title": "ما النتيجة إذا حاولنا حذف قيمة غير موجودة في BST حسب منطق البحث؟",
    "answer_1": "يتم حذف الجذر",
    "answer_2": "تنتهي العملية دون أي تعديل",
    "answer_3": "يتم إدخال القيمة بدل حذفها",
    "answer_4": "تُعاد بناء الشجرة",
    "correct_ans": "تنتهي العملية دون أي تعديل"
  },
  {
    "title": "في حال كانت الشجرة فارغة، ماذا يحدث عند محاولة الحذف؟",
    "answer_1": "يتم إنشاء عقدة جديدة",
    "answer_2": "يتم الوصول إلى NULL مباشرة",
    "answer_3": "يتم حذف الجذر",
    "answer_4": "تُنفذ العبور",
    "correct_ans": "يتم الوصول إلى NULL مباشرة"
  },
  {
    "title": "لماذا يتم تنفيذ عملية البحث قبل أي حذف في BST؟",
    "answer_1": "لتحديد نوع العبور",
    "answer_2": "للتأكد من وجود العقدة وتحديد موقعها",
    "answer_3": "لإعادة ترتيب الشجرة",
    "answer_4": "لتحديد عدد الأبناء",
    "correct_ans": "للتأكد من وجود العقدة وتحديد موقعها"
  },
  {
    "title": "في كود الإدخال إلى BST، ماذا يحدث إذا كانت الشجرة فارغة؟",
    "answer_1": "يتم تجاهل الإدخال",
    "answer_2": "تُنشأ عقدة جديدة وتصبح الجذر",
    "answer_3": "يتم الانتقال إلى الفرع الأيسر",
    "answer_4": "يتم تنفيذ العبور",
    "correct_ans": "تُنشأ عقدة جديدة وتصبح الجذر"
  },
  {
    "title": "أثناء الإدخال، متى تتوقف عملية التنقل داخل BST؟",
    "answer_1": "عند الوصول إلى الجذر",
    "answer_2": "عند الوصول إلى عقدة لها ابنان",
    "answer_3": "عند الوصول إلى مؤشر NULL",
    "answer_4": "عند مقارنة أول عقدة فقط",
    "correct_ans": "عند الوصول إلى مؤشر NULL"
  },
  {
    "title": "في كود الإدخال في BST ، لماذا نحتفظ بمؤشر للعقدة السابقة أثناء التنقل؟",
    "answer_1": "لتحديد نوع العبور",
    "answer_2": "لربط العقدة الجديدة في المكان الصحيح",
    "answer_3": "لتحديث قيمة الجذر",
    "answer_4": "لإنهاء العملية",
    "correct_ans": "لربط العقدة الجديدة في المكان الصحيح"
  },
  {
    "title": "في BST إذا كانت القيمة المُدخلة مساوية لقيمة عقدة موجودة، ماذا يحدث ؟",
    "answer_1": "يتم إدخالها في الفرع الأيسر",
    "answer_2": "يتم إدخالها في الفرع الأيمن",
    "answer_3": "لا يتم الإدخال",
    "answer_4": "يتم استبدال العقدة القديمة",
    "correct_ans": "لا يتم الإدخال"
  },
  {
    "title": "في كود الحذف في BST ، لماذا يتم التعامل مع حذف الجذر كحالة خاصة؟",
    "answer_1": "لأن الجذر لا يملك أبًا",
    "answer_2": "لأن الجذر دائمًا له ابنان",
    "answer_3": "لأن الجذر لا يمكن حذفه",
    "answer_4": "لأن الجذر يُحذف آخرًا",
    "correct_ans": "لأن الجذر لا يملك أبًا"
  },
  {
    "title": "في BST أثناء حذف الجذر وله ابن واحد فقط، ماذا يصبح الجذر الجديد؟",
    "answer_1": "NULL",
    "answer_2": "الابن الوحيد للجذر",
    "answer_3": "أصغر عنصر في الشجرة",
    "answer_4": "يبقى كما هو",
    "correct_ans": "الابن الوحيد للجذر"
  },
  {
    "title": "عند إدخال أول عنصر في BST، ما موقعه في الشجرة؟",
    "answer_1": "الفرع الأيسر",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الجذر",
    "answer_4": "لا يتم إدخاله",
    "correct_ans": "الجذر"
  },
  {
    "title": "أثناء الإدخال في BST، ما الشرط الذي يحدد الانتقال إلى الفرع الأيسر؟",
    "answer_1": "القيمة أكبر من العقدة الحالية",
    "answer_2": "القيمة أصغر من العقدة الحالية",
    "answer_3": "القيمة مساوية",
    "answer_4": "العقدة NULL",
    "correct_ans": "القيمة أصغر من العقدة الحالية"
  },
  {
    "title": "في كود الإدخال، ماذا يعني أن نصل إلى مؤشر NULL؟",
    "answer_1": "القيمة موجودة",
    "answer_2": "مكان مناسب لإدخال عقدة جديدة",
    "answer_3": "يجب إيقاف الإدخال",
    "answer_4": "الشجرة فارغة",
    "correct_ans": "مكان مناسب لإدخال عقدة جديدة"
  },
  {
    "title": "في العبور من نوع Inorder، ما أول جزء يتم زيارته؟",
    "answer_1": "العقدة",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الفرع الأيسر",
    "answer_4": "الجذر فقط",
    "correct_ans": "الفرع الأيسر"
  },
  {
    "title": "عند حذف عقدة ورقية، ماذا يحدث لمؤشر الأب؟",
    "answer_1": "يبقى كما هو",
    "answer_2": "يشير إلى NULL",
    "answer_3": "يشير إلى الجذر",
    "answer_4": "يشير إلى الابن الأيمن",
    "correct_ans": "يشير إلى NULL"
  },
  {
    "title": "في حالة حذف عقدة لها ابن واحد، كيف يتم الربط؟",
    "answer_1": "الأب يشير إلى NULL",
    "answer_2": "الأب يشير إلى الابن الوحيد",
    "answer_3": "الابن يشير إلى الجذر",
    "answer_4": "يتم حذف الشجرة",
    "correct_ans": "الأب يشير إلى الابن الوحيد"
  },
  {
    "title": "في حذف عقدة لها ابنان، من أين نبدأ البحث عن العقدة البديلة؟",
    "answer_1": "الفرع الأيسر",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الجذر",
    "answer_4": "العقدة نفسها",
    "correct_ans": "الفرع الأيمن"
  },
  {
    "title": "أي تصرّف يؤدي إلى كسر خاصية BST أثناء الإدخال؟",
    "answer_1": "الانتقال يسارًا عند قيمة أصغر",
    "answer_2": "الانتقال يمينًا عند قيمة أكبر",
    "answer_3": "إدخال قيمة أكبر في الفرع الأيسر",
    "answer_4": "التوقف عند NULL",
    "correct_ans": "إدخال قيمة أكبر في الفرع الأيسر"
  },
  {
    "title": "في بناء Heap من مصفوفة، لماذا نبدأ عملية heapify من آخر عقدة غير ورقية؟",
    "answer_1": "لأنها الجذر",
    "answer_2": "لأن العقد الورقية لا تحتاج معالجة",
    "answer_3": "لأنها أكبر عقدة",
    "answer_4": "لتقليل عدد العناصر",
    "correct_ans": "لأن العقد الورقية لا تحتاج معالجة"
  },
  {
    "title": "في كود حذف الجذر من Heap، ما أول خطوة يتم تنفيذها قبل إعادة ترتيب Heap؟",
    "answer_1": "حذف آخر عنصر",
    "answer_2": "نقل آخر عنصر إلى مكان الجذر",
    "answer_3": "استدعاء heapifyUp",
    "answer_4": "إيقاف التنفيذ",
    "correct_ans": "نقل آخر عنصر إلى مكان الجذر"
  },
  {
    "title": "اعتبر الكود التالي:\n<pre>int partition(int[] a, int left, int right) {\n    int pivot = a[(left + right) / 2];\n\n    while (left <= right) {\n        while (a[left] < pivot)\n            left++;\n        while (a[right] > pivot)\n            right--;\n\n        if (left <= right) {\n            swap(a, left, right);\n            left++;\n            right--;\n        }\n    }\n    return left;\n}</pre>\nما الذي تمثله القيمة المعادة من الدالة partition؟",
    "answer_1": "موقع المحور النهائي",
    "answer_2": "عدد التبديلات",
    "answer_3": "نقطة الفصل بين القسمين الناتجين",
    "answer_4": "عدد العناصر الأصغر من المحور",
    "correct_ans": "نقطة الفصل بين القسمين الناتجين"
  },
  {
    "title": "اعتبر الكود التالي:\n<pre>int pivot = a[right];</pre>\nأي عبارة صحيحة حول اختيار pivot بهذه الطريقة؟",
    "answer_1": "يضمن توازن الأقسام دائمًا",
    "answer_2": "قد يؤدي لأداء سيئ إذا كانت المصفوفة مرتبة",
    "answer_3": "يمنع الاستدعاء التراجعي",
    "answer_4": "يؤدي لترتيب كامل بعد خطوة واحدة",
    "correct_ans": "قد يؤدي لأداء سيئ إذا كانت المصفوفة مرتبة"
  },
  {
    "title": "لدينا الكود التالي: \n <pre>function mergeSort(low, high, t) {\n    if(low != high) {\n        let mid = parseInt((low + high) / 2);\n        mergeSort(low, mid, t);\n        mergeSort(___Here___);\n        merge(low, mid, high, t);\n    }\n}</pre>\nأي مما يلي يجب وضعه في المكان Here :",
    "answer_1": "mid - 1, high, t",
    "answer_2": "mid, high, t",
    "answer_3": "mid + 1, high, t",
    "answer_4": "mid, high - 1, t",
    "correct_ans": "mid + 1, high, t"
  },
  {
    "title": "استدعاء التابع MergeSort(2, 3, a) يقوم ب:",
    "answer_1": "Error",
    "answer_2": "ترتيب العنصر الثاني والثالث في a ",
    "answer_3": "حذف العنصرين الثاني والثالث من a",
    "answer_4": "لا يقوم بشيء",
    "correct_ans": "ترتيب العنصر الثاني والثالث في a "
  },
  {
    "title": "<pre>while(j <= high) {\n        aux[k] = t[j];\n        j++;\n        k++;\n    }\n</pre> وظيفة الحلقة السابقة في تابع merge هي :",
    "answer_1": "نسخ عناصر المصفوفة الثانية إلى المصفوفة المساعدة في حال بقاء عناصر بالمصفوفة الثانية",
    "answer_2": "حذف العناصر المكررة في المصفوقة المساعدة",
    "answer_3": "نسخ عناصر المصفوفة الثانية إلى المصفوفة المساعدة في حال بقاء عناصر بالمصفوفة الأولى",
    "answer_4": "نسخ t إلى aux",
    "correct_ans": "نسخ عناصر المصفوفة الثانية إلى المصفوفة المساعدة في حال بقاء عناصر بالمصفوفة الثانية"
  },
  {
    "title": "<pre>\nfor (i = 2; i <= n; i++)\n{\n        elt = x[i];\n        s = i;\n        f = s / 2;\n        while (___Here___)\n        {\n        x[s] = x[f];\n        s = f;\n        if (s > 1) f = s / 2;\n        else f = 1;\n        }\n        x[s] = elt;\n}</pre> ما الشرط الواجب وضعه في المكان Here وفق HeapSort ؟",
    "answer_1": "(s < 1) && (x[f] < elt)",
    "answer_2": "(s > 1) && (x[f] < elt)",
    "answer_3": "(s > 1) || (x[f] < elt)",
    "answer_4": "(s < 1) || (x[f] < elt)",
    "correct_ans": "(s > 1) && (x[f] < elt)"
  },
  {
    "title": "<pre>\nfor (i = 2; i <= n; i++)\n{\n        elt = x[i];\n        s = i;\n        f = ___Here___;\n        while ((s > 1) && (x[f] < elt))\n        {\n        x[s] = x[f];\n        s = f;\n        if (s > 1) f = s / 2;\n        else f = 1;\n        }\n        x[s] = elt;\n}</pre> ما القيمة الواجب وضعها في المكان Here وفق HeapSort ؟",
    "answer_1": "s * 2",
    "answer_2": "s - 1",
    "answer_3": "s / 2",
    "answer_4": "s * s",
    "correct_ans": "s / 2"
  },
  {
    "title": "<pre>while ((s > 0) && (iValue < value))\n{\nx[f] = x[s];\nf = s;\ns = ___Here___;\nif (s+1 <= i-1)\n        if (x[s] < x[s+1]) s = s + 1;\nif (s < i) value = x[s];\nelse s = 0;\n}</pre> ما القيمة الواجب وضعها في المكان Here وفق HeapSort ؟",
    "answer_1": "f * 2",
    "answer_2": "s / 2",
    "answer_3": "f / 2",
    "answer_4": "s * 2",
    "correct_ans": "f * 2"
  },
  {
    "title": "إذا كان لدينا الجنود التالية أسماؤهم  A,B,C,D وبدأنا العد من الجندي  Aوكانت خطوة العد  n=3 فمن سيكون الجندي الناجي وفق خوارزمية جوزيف ؟",
    "answer_1": "A",
    "answer_2": "B",
    "answer_3": "C",
    "answer_4": "D",
    "correct_ans": "A"
  },
  {
    "title": "إذا كان لدينا الجنود التالية أسماؤهم  A,B,C,D,E وبدأنا العد من الجندي  Aوكانت خطوة العد  n=2 فمن سيكون الجندي الناجي وفق خوارزمية جوزيف ؟",
    "answer_1": "A",
    "answer_2": "E",
    "answer_3": "C",
    "answer_4": "D",
    "correct_ans": "C"
  },
  {
    "title": "باعتبار أن الجذر ذا دليل 1 فإن دليل (index) الولد اليميني لعقدة ما يساوي",
    "answer_1": "دليل الأب * 2 + 1",
    "answer_2": "دليل الأب",
    "answer_3": "دليل الأب * 2",
    "answer_4": "دليل الأب + 1",
    "correct_ans": "دليل الأب * 2 + 1"
  },
  {
    "title": "باعتبار أن الجذر ذا دليل 1 فإن دليل (index) الولد اليساري لعقدة ما يساوي",
    "answer_1": "دليل الأب * 2 + 1",
    "answer_2": "دليل الأب",
    "answer_3": "دليل الأب * 2",
    "answer_4": "دليل الأب + 1",
    "correct_ans": "دليل الأب * 2"
  },
  {
    "title": "تعتمد نظرية هوفمان على إعطاء الشيفرة الأكبر ل:",
    "answer_1": "الحرف الأكبر",
    "answer_2": "الحرف الأكثر تكراراً",
    "answer_3": "الحرف الأقل تكراراً",
    "answer_4": "الحرف الأصغر",
    "correct_ans": "الحرف الأقل تكراراً"
  },
  {
    "title": "ليكن لدينا التابع :<pre>public static int findminfreq(int p, NodeType node[]) {\n        int min = 99, l = -1, k;\n        for(k = 0; k < p; k++)\n                if(_____Here_____) {\n                        min = node[k].freq;\n                        l = k;\n                }\n        node[l].freq = false;\n        return l;\n}</pre>ما الشرط الواجب وضعه في المكان Here وفق هوفمان ؟",
    "answer_1": "(node[k].freq < min) && (node[k].del)",
    "answer_2": "(node[k].freq > min) && (node[k].del)",
    "answer_3": "(node[k].freq < min) || (node[k].del)",
    "answer_4": "(node[k].freq <= min) && (node[k].del)",
    "correct_ans": "(node[k].freq < min) && (node[k].del)"
  },
  {
    "title": "أي من التسلسلات التالية تمثل Heap صحيحة؟",
    "answer_1": "16 14 10 4 7 9 3 2 8 1",
    "answer_2": "16 14 10 8 7 9 3 2 4 1",
    "answer_3": "16 14 10 8 1 9 3 2 4 7",
    "answer_4": "16 14 3 4 1 9 10 8 2 7",
    "correct_ans": "16 14 10 8 7 9 3 2 4 1"
  },
  {
    "title": "أي من المصفوفات التالية تمثل Binary Max-Heap؟",
    "answer_1": "[26, 13, 17, 14, 11, 9, 15]",
    "answer_2": "[26, 15, 14, 17, 11, 9, 13]",
    "answer_3": "[26, 15, 17, 14, 11, 9, 13]",
    "answer_4": "[26, 15, 13, 14, 11, 9, 17]",
    "correct_ans": "[26, 15, 17, 14, 11, 9, 13]"
  },
  {
    "title": "لدينا Binary Max-Heap ممثل بالمصفوفة:\n<pre>25, 14, 16, 13, 10, 8, 12</pre>\nما هو شكل المصفوفة بعد تنفيذ عمليتي حذف متتاليتين؟",
    "answer_1": "14,13,8,12,10",
    "answer_2": "14,12,13,10,8",
    "answer_3": "14,13,12,8,10",
    "answer_4": "14,13,12,10,8",
    "correct_ans": "14,13,12,8,10"
  },
  {
    "title": "ما هو شكل المصفوفة بعد تنفيذ عمليتي حذف متتاليتين على Binary Max-Heap ممثل بالمصفوفة:\n<pre>30, 20, 15, 10, 8, 12, 6</pre>",
    "answer_1": "20,10,15,6,8",
    "answer_2": "20,15,12,10,8",
    "answer_3": "20,15,10,8,6",
    "answer_4": "20,15,10,6,8",
    "correct_ans": "20,15,10,8,6"
  },
  {
    "title": "لدينا المصفوفة التالية:\n<pre>⟨89, 19, 50, 17, 12, 15, 2, 5, 7, 11, 6, 9, 100⟩</pre>\nما هو أقل عدد من عمليات التبديل اللازمة لتحويلها إلى Max-Heap؟",
    "answer_1": "4",
    "answer_2": "5",
    "answer_3": "2",
    "answer_4": "3",
    "correct_ans": "3"
  },
  {
    "title": "ما هو أقل عدد من عمليات التبديل اللازمة لتحويل المصفوفة التالية إلى Max-Heap؟\n<pre>⟨45, 20, 30, 10, 15, 25, 5, 8, 12⟩</pre>",
    "answer_1": "2",
    "answer_2": "3",
    "answer_3": "4",
    "answer_4": "5",
    "correct_ans": "2"
  }
]